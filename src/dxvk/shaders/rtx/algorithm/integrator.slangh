/*
* Copyright (c) 2022-2023, NVIDIA CORPORATION. All rights reserved.
*
* Permission is hereby granted, free of charge, to any person obtaining a
* copy of this software and associated documentation files (the "Software"),
* to deal in the Software without restriction, including without limitation
* the rights to use, copy, modify, merge, publish, distribute, sublicense,
* and/or sell copies of the Software, and to permit persons to whom the
* Software is furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
* DEALINGS IN THE SOFTWARE.
*/
#pragma once

#include "rtx/utility/noise.slangh"
#include "rtx/utility/color.slangh"
#include "rtx/utility/packing.slangh"
#include "rtx/utility/debug_view_helpers.slangh"
#include "rtx/utility/gbuffer_helpers.slangh"
#include "rtx/concept/ray/ray.slangh"
#include "rtx/pass/instance_definitions.slangh"
#include "rtx/concept/surface/surface.slangh"
#include "rtx/concept/surface_material/surface_material.slangh"
#include "rtx/concept/light/light.slangh"
#include "rtx/algorithm/integrator_helpers.slangh"
#include "rtx/algorithm/lighting.slangh"
#include "rtx/algorithm/resolve.slangh"
#include "rtx/algorithm/visibility.slangh"
#include "rtx/algorithm/neecache.h"

struct IndirectSampleData
{
  float16_t firstSampledLobePdf;    
  float16_t firstSampledSolidAnglePdf;
  bool firstSampledLobeIsSpecular;
  bool insideMedium; 

  [mutating] void unpack(const uint encodedData) 
  {
    firstSampledLobePdf = abs(unpackFloat2x16(encodedData)).x;
    firstSampledSolidAnglePdf = abs(unpackFloat2x16(encodedData)).y;

    firstSampledLobeIsSpecular = packedFlagGet(encodedData, 1 << 15);
    insideMedium = packedFlagGet(encodedData, 1 << 31);
  } 

  uint pack()
  {
    uint encodedData = packFloat2x16(abs(f16vec2(firstSampledLobePdf, firstSampledSolidAnglePdf)));
    
    // Note: Encode flags into the sign bits of each float. This must be done manually because -0 may not be properly
    // stored if the value is 0 as -0 and +0 tend to be treated the same. Assumes the pdfs are always 0 or greater
    // Lobe pdf and and solid angle pdfs are expected to be >= 0
    encodedData = packedFlagSet(encodedData, (uint(firstSampledLobeIsSpecular) << 15) | (uint(insideMedium) << 31));

    return encodedData;
  }

  [mutating] void load(u16vec2 texelIndex, RWTexture2D<uint> encodedIndirectSampleDataTexture) 
  {
    unpack(encodedIndirectSampleDataTexture[texelIndex]);
  }

  [mutating] void load(u16vec2 texelIndex, Texture2D<uint> encodedIndirectSampleDataTexture) 
  {
    unpack(encodedIndirectSampleDataTexture[texelIndex]);
  }

  void store(u16vec2 texelIndex, RWTexture2D<uint> encodedIndirectSampleDataTexture) 
  {
    encodedIndirectSampleDataTexture[texelIndex] = pack();
  }

  bool isValidSample()
  {
    return firstSampledSolidAnglePdf > 0.h;
  }
}

float calculateSpreadAngleFromSolidAnglePdf(float16_t incomingSpreadAngle, float16_t solidAnglePdf)
{
  // Note: If the spread angle is exactly 1.0, this is almost certainly the result of sampling a dirac on something such as perfectly
  // smooth opaque or translucent objects as we use a PDF of 1 in these cases (so that division by the PDF works out properly), and in
  // these cases the typical spread angle from PDF math breaks down (as it assumes uniform or slightly biased sampling over a sphere of
  // solid angles rather than just sampling a specific direction always like is done with the dirac case).
  // This may occasionally generate a bad spread angle for something that accidently has a PDF of exactly 1 randomly, but this should
  // happen so rarely that it is not an issue in practice. Additionally, this allows us to simply check this case here rather than
  // use more complex logic to indicate when a dirac was sampled from a material (which would likely be slower performance wise).
  if (solidAnglePdf == 1.0f)
  {
    return incomingSpreadAngle;
  }

  // This is a guesstimate at the cone angle that is optimal for sampling textures for surfaces found by BRDF rays.
  // The math here is derived from the assumption that the sampling PDF is uniform in a certain cone.
  // This assumption is of course incorrect for any reasonable importance sampling scheme, but it seems to work here.
  //
  // So, if we have a cone with apex angle 2*Theta, then it subtends the following solid angle:
  //   W = 4*pi * sin^2(Theta/2)
  //   https://en.wikipedia.org/wiki/Solid_angle#Solid_angles_for_common_objects 
  //
  // From the assumption that the PDF is uniform in this cone, we set:
  //   W = 1.0 / pdfW,
  // and solve the resulting equation for Theta, getting the below expression.
  //
  // The 'indirectRaySpreadAngleFactor' is a tweakable parameter compensating for the fact that we take multiple samples
  // in the cone. Normally it should be in the [0..1] range. Set it to 0 to disable the spread angle widening.
  float16_t newSpreadAngle = 2.0 * asin(sqrt(saturate(1.0 / (4.0 * pi * solidAnglePdf)))) * cb.indirectRaySpreadAngleFactor;
  
  return max(incomingSpreadAngle, newSpreadAngle);
}

Ray sampleDirection(
  inout RNG randomState, inout bool insideMedium, inout vec3 throughput,
  Ray ray, MinimalRayInteraction minimalRayInteraction, MinimalSurfaceInteraction minimalSurfaceInteraction,
  PolymorphicSurfaceMaterialInteraction polymorphicSurfaceMaterialInteraction,
  out uint8_t sampledLobe, out float16_t sampledLobePdf, out float16_t solidAnglePdf,
  bool isPrimaryIndirectSample)
{
  // Sample from the material

  SurfaceMaterialInteractionSample surfaceMaterialInteractionSample;
  SurfaceMaterialInteractionLobeSample surfaceMaterialInteractionLobeSample;
  bool penetrateSurface = false;

  polymorphicSurfaceMaterialInteractionCalcSample(
    polymorphicSurfaceMaterialInteraction, randomState, minimalRayInteraction,
    surfaceMaterialInteractionSample, surfaceMaterialInteractionLobeSample,
    insideMedium, penetrateSurface, isPrimaryIndirectSample);

  sampledLobe = surfaceMaterialInteractionLobeSample.lobe;
  sampledLobePdf = surfaceMaterialInteractionLobeSample.pdf;
  solidAnglePdf = min(surfaceMaterialInteractionSample.solidAnglePdf, float16Max);

  // Create a ray from the material sample

  Ray sampledRay = rayCreateDirection(
    minimalRayInteraction, minimalSurfaceInteraction, ray, surfaceMaterialInteractionSample.inputDirection, penetrateSurface);

  sampledRay.spreadAngle = calculateSpreadAngleFromSolidAnglePdf(sampledRay.spreadAngle, solidAnglePdf);

  // Combine sample throughput into the throughput

  const vec3 directionSampleThroughput = surfaceMaterialInteractionSample.throughput / surfaceMaterialInteractionLobeSample.pdf;

  throughput *= directionSampleThroughput;

  return sampledRay;
}

Ray sampleDirection(
  inout RNG randomState, inout bool insideMedium, inout vec3 throughput,
  Ray ray, MinimalRayInteraction minimalRayInteraction, MinimalSurfaceInteraction minimalSurfaceInteraction,
  PolymorphicSurfaceMaterialInteraction polymorphicSurfaceMaterialInteraction,
  out uint8_t sampledLobe, bool isPrimaryIndirectSample)
{
  float16_t dummySampledLobePdf, dummySolidAnglePdf;

  return sampleDirection(
    randomState, insideMedium, throughput,
    ray, minimalRayInteraction, minimalSurfaceInteraction,
    polymorphicSurfaceMaterialInteraction, sampledLobe, dummySampledLobePdf, dummySolidAnglePdf, isPrimaryIndirectSample);
}

bool evalMediumChange(
  bool oldInsideMedium, bool insideMedium,
  PolymorphicSurfaceMaterialInteraction polymorphicSurfaceMaterialInteraction,
  inout uint16_t mediumMaterialIndex)
{
  // Set the material medium index if a medium was entered or exited
  // Note: This does not work for nested translucency as most recent medium entered is stored, but this is a fine thing to not support as
  // it is not super common. Additionally this path should only be invoked if PSTR is desired, and only in the case of actual thick translucency
  // which changes the medium flag.

  const bool enteredMedium = !oldInsideMedium && insideMedium;
  const bool exitedMedium = oldInsideMedium && !insideMedium;

  if (enteredMedium)
  {
    // Note: For now we always know the only type of material which can trigger this path is the translucent material, so no need to check it.
    const TranslucentSurfaceMaterialInteraction translucentSurfaceMaterialInteraction =
      translucentSurfaceMaterialInteractionCreate(polymorphicSurfaceMaterialInteraction);

    mediumMaterialIndex = translucentSurfaceMaterialInteraction.sourceSurfaceMaterialIndex;

    return true;
  }
  else if (exitedMedium)
  {
    mediumMaterialIndex = BINDING_INDEX_INVALID;

    return true;
  }

  return false;
}

bool evalNEESecondary(
  LightSample lightSample, 
  float invSelectionPdf, 
  uint8_t sampledTransportPortalIndex, 
  PortalSpace2BitsType portalSpace,
  uint8_t objectMask,
  bool isViewModelSurface,
  Ray viewRay,
  MinimalRayInteraction minimalRayInteraction, 
  MinimalSurfaceInteraction minimalSurfaceInteraction,
  OpaqueSurfaceMaterialInteraction opaqueSurfaceMaterialInteraction,
  out vec3 diffuseLight,
  out vec3 specularLight)
{
  diffuseLight = specularLight = 0;

  // Setup and trace the visibility ray

  uint8_t rayMask = OBJECT_MASK_OPAQUE | (objectMask & OBJECT_MASK_ALL_DYNAMIC);
  if (cb.enableIndirectTranslucentShadows) rayMask |= OBJECT_MASK_TRANSLUCENT;

  VisibilityResult visibility = traceVisibilityRay(minimalSurfaceInteraction,
    lightSample.position, false, rayMask,
    visibilityModeEnableTranslucentMaterials,
    sampledTransportPortalIndex, portalSpace,
    minimalRayInteraction.coneRadius, viewRay.spreadAngle, 1.0, isViewModelSurface);


  if (visibility.hasOpaqueHit)
    return false;

  // Evaluate the material and accumulate throughput and hit distance

  const SurfaceMaterialInteractionSplitWeight splitWeight = opaqueSurfaceMaterialInteractionCalcProjectedWeight(
    opaqueSurfaceMaterialInteraction, minimalRayInteraction, visibility.rayDirection);

  const float lightSampleThroughput = invSelectionPdf / lightSample.solidAnglePdf;

  // Accumulate Radiance

  const vec3 lightThroughput = lightSampleThroughput * vec3(visibility.attenuation);
  const vec3 attenuatedRadiance = lightSample.radiance * lightThroughput;

  diffuseLight = attenuatedRadiance * splitWeight.diffuseReflectionWeight;
  specularLight = attenuatedRadiance * splitWeight.specularReflectionWeight;

  return true;
}

LightSample getLightSampleFromTriangle(int surfaceIndex, int primitiveIndex, vec2 uv, float trianglePdf, vec3 shadingPosition)
{
#define USE_SIMIPLIFIED_MODEL 1

  SURFACE_CREATE_READ(surface0, surfaceIndex, surfaces);
  Surface surface = surface0;
#if USE_SIMIPLIFIED_MODEL
  surface.isEmissive = false;
  surface.isEmissiveBlend = false;
  surface.isStatic = true;
  surface.isMatte = true;
  surface.texcoordGenerationMode = uint(TexGenMode::None);
  surface.previousPositionBufferIndex = BINDING_INDEX_INVALID;
  surface.normalBufferIndex = BINDING_INDEX_INVALID;
  surface.color0BufferIndex = BINDING_INDEX_INVALID;
  surface.isAnimatedWater = false;
  surface.textureAlphaArg1Source = uint(RtTextureArgSource::None);
  surface.textureAlphaArg2Source = uint(RtTextureArgSource::None);
  surface.textureAlphaOperation = uint(DxvkRtTextureOperation::Disable);
  surface.tFactor = 0;
#endif

  RayInteraction rayInteracton = {};
  rayInteracton.barycentricCoordinates = barycentricsToUint(uvToBary(uv));
  rayInteracton.primitiveIndex = primitiveIndex;
  Ray dummyRay = {};

  SurfaceInteraction surfaceInteraction = surfaceInteractionCreate(surface, rayInteracton, dummyRay, false, false);
#if USE_SIMIPLIFIED_MODEL
  surfaceInteraction.positionError = 0;
  surfaceInteraction.motion = 0;
  surfaceInteraction.interpolatedTangent = f16vec3(0);
  surfaceInteraction.interpolatedBitangent = f16vec3(0);
  surfaceInteraction.vertexColor = f16vec4(0);
#endif

  rayInteracton.viewDirection = normalize(surfaceInteraction.position - shadingPosition);

  const MemoryPolymorphicSurfaceMaterial memoryPolymorphicSurfaceMaterial = surfaceMaterials[surface.surfaceMaterialIndex];
  const uint8_t polymorphicType = memoryPolymorphicSurfaceMaterialGetTypeHelper(memoryPolymorphicSurfaceMaterial);

  LightSample lightSample = {};
  lightSample.position = surfaceInteraction.position;
  lightSample.normal = surfaceInteraction.interpolatedNormal;
  float16_t lightPdf = trianglePdf * getLightSamplingSolidAnglePDF(
    surfaceInteraction.triangleArea, surfaceInteraction.position, surfaceInteraction.triangleNormal, shadingPosition);
  lightSample.solidAnglePdf = lightPdf;
  lightSample.radiance = 0;

  if (polymorphicType == surfaceMaterialTypeOpaque)
  {
    OpaqueSurfaceMaterial opaqueSurfaceMaterial = opaqueSurfaceMaterialCreate(surface.surfaceMaterialIndex, memoryPolymorphicSurfaceMaterial);
#if USE_SIMIPLIFIED_MODEL
    opaqueSurfaceMaterial.albedoOpacityTextureIndex = BINDING_INDEX_INVALID;
    opaqueSurfaceMaterial.normalTextureIndex = BINDING_INDEX_INVALID;
    opaqueSurfaceMaterial.tangentTextureIndex = BINDING_INDEX_INVALID;
    opaqueSurfaceMaterial.roughnessTextureIndex = BINDING_INDEX_INVALID;
    opaqueSurfaceMaterial.metallicTextureIndex = BINDING_INDEX_INVALID;
    opaqueSurfaceMaterial.anisotropy = 1.0;
    opaqueSurfaceMaterial.albedoOpacityConstant = 0.0;
    opaqueSurfaceMaterial.roughnessConstant = 0.0;
    opaqueSurfaceMaterial.metallicConstant = 0.0;
    opaqueSurfaceMaterial.spriteSheetRows = 0;
    opaqueSurfaceMaterial.spriteSheetCols = 0;
    opaqueSurfaceMaterial.spriteSheetFPS = 0;
    opaqueSurfaceMaterial.thinFilmThicknessConstant = 0.0;
    opaqueSurfaceMaterial.flags = 0;
#endif

    const OpaqueSurfaceMaterialInteraction opaqueSurfaceMaterialInteraction =
      opaqueSurfaceMaterialInteractionCreate(opaqueSurfaceMaterial, surface, surfaceInteraction, rayInteracton);

    lightSample.radiance = opaqueSurfaceMaterialInteraction.emissiveRadiance;
  }
  return lightSample;
}