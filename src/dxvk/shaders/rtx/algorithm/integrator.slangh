/*
* Copyright (c) 2022-2023, NVIDIA CORPORATION. All rights reserved.
*
* Permission is hereby granted, free of charge, to any person obtaining a
* copy of this software and associated documentation files (the "Software"),
* to deal in the Software without restriction, including without limitation
* the rights to use, copy, modify, merge, publish, distribute, sublicense,
* and/or sell copies of the Software, and to permit persons to whom the
* Software is furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
* DEALINGS IN THE SOFTWARE.
*/
#pragma once

#include "rtx/utility/noise.slangh"
#include "rtx/utility/color.slangh"
#include "rtx/utility/packing.slangh"
#include "rtx/utility/debug_view_helpers.slangh"
#include "rtx/utility/gbuffer_helpers.slangh"
#include "rtx/concept/ray/ray.slangh"
#include "rtx/pass/instance_definitions.slangh"
#include "rtx/concept/surface/surface.slangh"
#include "rtx/concept/surface_material/surface_material.slangh"
#include "rtx/concept/light/light.slangh"
#include "rtx/algorithm/integrator_helpers.slangh"
#include "rtx/algorithm/lighting.slangh"
#include "rtx/algorithm/resolve.slangh"
#include "rtx/algorithm/visibility.slangh"

struct IndirectSampleData
{
  float16_t firstSampledLobePdf;    
  float16_t firstSampledSolidAnglePdf;
  bool firstSampledLobeIsSpecular;
  bool insideMedium; 

  [mutating] void unpack(const uint encodedData) 
  {
    firstSampledLobePdf = abs(unpackFloat2x16(encodedData)).x;
    firstSampledSolidAnglePdf = abs(unpackFloat2x16(encodedData)).y;

    firstSampledLobeIsSpecular = packedFlagGet(encodedData, 1 << 15);
    insideMedium = packedFlagGet(encodedData, 1 << 31);
  } 

  uint pack()
  {
    uint encodedData = packFloat2x16(abs(f16vec2(firstSampledLobePdf, firstSampledSolidAnglePdf)));
    
    // Note: Encode flags into the sign bits of each float. This must be done manually because -0 may not be properly
    // stored if the value is 0 as -0 and +0 tend to be treated the same. Assumes the pdfs are always 0 or greater
    // Lobe pdf and and solid angle pdfs are expected to be >= 0
    encodedData = packedFlagSet(encodedData, (uint(firstSampledLobeIsSpecular) << 15) | (uint(insideMedium) << 31));

    return encodedData;
  }

  [mutating] void load(u16vec2 texelIndex, RWTexture2D<uint> encodedIndirectSampleDataTexture) 
  {
    unpack(encodedIndirectSampleDataTexture[texelIndex]);
  }

  [mutating] void load(u16vec2 texelIndex, Texture2D<uint> encodedIndirectSampleDataTexture) 
  {
    unpack(encodedIndirectSampleDataTexture[texelIndex]);
  }

  void store(u16vec2 texelIndex, RWTexture2D<uint> encodedIndirectSampleDataTexture) 
  {
    encodedIndirectSampleDataTexture[texelIndex] = pack();
  }

  bool isValidSample()
  {
    return firstSampledSolidAnglePdf > 0.h;
  }
}

float calculateSpreadAngleFromSolidAnglePdf(float16_t incomingSpreadAngle, float16_t solidAnglePdf)
{
  // Note: If the spread angle is exactly 1.0, this is almost certainly the result of sampling a dirac on something such as perfectly
  // smooth opaque or translucent objects as we use a PDF of 1 in these cases (so that division by the PDF works out properly), and in
  // these cases the typical spread angle from PDF math breaks down (as it assumes uniform or slightly biased sampling over a sphere of
  // solid angles rather than just sampling a specific direction always like is done with the dirac case).
  // This may occasionally generate a bad spread angle for something that accidently has a PDF of exactly 1 randomly, but this should
  // happen so rarely that it is not an issue in practice. Additionally, this allows us to simply check this case here rather than
  // use more complex logic to indicate when a dirac was sampled from a material (which would likely be slower performance wise).
  if (solidAnglePdf == 1.0f)
  {
    return incomingSpreadAngle;
  }

  // This is a guesstimate at the cone angle that is optimal for sampling textures for surfaces found by BRDF rays.
  // The math here is derived from the assumption that the sampling PDF is uniform in a certain cone.
  // This assumption is of course incorrect for any reasonable importance sampling scheme, but it seems to work here.
  //
  // So, if we have a cone with apex angle 2*Theta, then it subtends the following solid angle:
  //   W = 4*pi * sin^2(Theta/2)
  //   https://en.wikipedia.org/wiki/Solid_angle#Solid_angles_for_common_objects 
  //
  // From the assumption that the PDF is uniform in this cone, we set:
  //   W = 1.0 / pdfW,
  // and solve the resulting equation for Theta, getting the below expression.
  //
  // The 'indirectRaySpreadAngleFactor' is a tweakable parameter compensating for the fact that we take multiple samples
  // in the cone. Normally it should be in the [0..1] range. Set it to 0 to disable the spread angle widening.
  float16_t newSpreadAngle = 2.0 * asin(sqrt(saturate(1.0 / (4.0 * pi * solidAnglePdf)))) * cb.indirectRaySpreadAngleFactor;
  
  return max(incomingSpreadAngle, newSpreadAngle);
}

Ray sampleDirection(
  inout RNG randomState, inout bool insideMedium, inout vec3 throughput,
  Ray ray, MinimalRayInteraction minimalRayInteraction, MinimalSurfaceInteraction minimalSurfaceInteraction,
  PolymorphicSurfaceMaterialInteraction polymorphicSurfaceMaterialInteraction,
  out uint8_t sampledLobe, out float16_t sampledLobePdf, out float16_t solidAnglePdf,
  bool isPrimaryIndirectSample)
{
  // Sample from the material

  SurfaceMaterialInteractionSample surfaceMaterialInteractionSample;
  SurfaceMaterialInteractionLobeSample surfaceMaterialInteractionLobeSample;
  bool penetrateSurface = false;

  polymorphicSurfaceMaterialInteractionCalcSample(
    polymorphicSurfaceMaterialInteraction, randomState, minimalRayInteraction,
    surfaceMaterialInteractionSample, surfaceMaterialInteractionLobeSample,
    insideMedium, penetrateSurface, isPrimaryIndirectSample);

  sampledLobe = surfaceMaterialInteractionLobeSample.lobe;
  sampledLobePdf = surfaceMaterialInteractionLobeSample.pdf;
  solidAnglePdf = min(surfaceMaterialInteractionSample.solidAnglePdf, float16Max);

  // Create a ray from the material sample

  Ray sampledRay = rayCreateDirection(
    minimalRayInteraction, minimalSurfaceInteraction, ray, surfaceMaterialInteractionSample.inputDirection, penetrateSurface);

  sampledRay.spreadAngle = calculateSpreadAngleFromSolidAnglePdf(sampledRay.spreadAngle, solidAnglePdf);

  // Combine sample throughput into the throughput

  const vec3 directionSampleThroughput = surfaceMaterialInteractionSample.throughput / surfaceMaterialInteractionLobeSample.pdf;

  throughput *= directionSampleThroughput;

  return sampledRay;
}

int2 pointToAddress(vec3 position, uvec2 pixel)
{
  vec3 cameraPos = cameraGetWorldPosition(cb.camera);
  float extend = 1000;//cb.debugKnob.y * 10 + 1;
  vec3 origin = cameraPos - extend * 0.5;
  vec3 UVW = (position - origin) / extend;
  if (any(UVW < 0) || any(UVW >= 1))
  {
    return int2(-1,-1);
  }
  ivec3 UVWi = UVW * RADIANCE_CACHE_PROBE_RESOLUTION;
  ivec2 UV2D = ivec2(UVWi.y * RADIANCE_CACHE_PROBE_RESOLUTION + UVWi.x, UVWi.z);

  int mipRes = RADIANCE_CACHE_MIP_RESOLUTION;
  uvec2 offset = 0;//(pixel + cb.frameIdx) & (mipRes - 1);
  return UV2D * mipRes + offset;
}

int2 pointDirectionToAddress(vec3 position, f16vec3 direction)
{
  vec3 cameraPos = cameraGetWorldPosition(cb.camera);
  float extend = cb.debugKnob.y * 10 + 1;
  vec3 origin = cameraPos - extend * 0.5;
  vec3 UVW = (position - origin) / extend;
  if (any(UVW < 0) || any(UVW >= 1))
  {
    return int2(-1,-1);
  }
  ivec3 UVWi = UVW * RADIANCE_CACHE_PROBE_RESOLUTION;
  ivec2 UV2D = ivec2(UVWi.y * RADIANCE_CACHE_PROBE_RESOLUTION + UVWi.x, UVWi.z);

  int mipRes = RADIANCE_CACHE_MIP_RESOLUTION;
  vec2 directionUV = sphereDirectionToUnsignedOctahedral(direction);
  ivec2 directionUVi = clamp(directionUV * mipRes, 0, mipRes-1);
  return UV2D * mipRes + directionUVi;
}

Ray sampleDirection2(
  inout RNG randomState, inout bool insideMedium, inout vec3 throughput,
  Ray ray, MinimalRayInteraction minimalRayInteraction, MinimalSurfaceInteraction minimalSurfaceInteraction,
  PolymorphicSurfaceMaterialInteraction polymorphicSurfaceMaterialInteraction,
  out uint8_t sampledLobe, out float16_t sampledLobePdf, out float16_t solidAnglePdf,
  bool isPrimaryIndirectSample)
{
  // Sample from the material

  SurfaceMaterialInteractionSample surfaceMaterialInteractionSample;
  SurfaceMaterialInteractionLobeSample surfaceMaterialInteractionLobeSample;
  bool penetrateSurface = false;

  float finalTargetPDF = 0;
  float weightSum = 0;
  int M = cb.debugKnob.x;
  vec3 finalL = 0;

  int2 testAddress = pointDirectionToAddress(minimalSurfaceInteraction.position, f16vec3(0,0,1));
  bool useBSDFSampling = M == 0 || any(testAddress == -1);
  if (useBSDFSampling)
  {
    polymorphicSurfaceMaterialInteractionCalcSample(
      polymorphicSurfaceMaterialInteraction, randomState, minimalRayInteraction,
      surfaceMaterialInteractionSample, surfaceMaterialInteractionLobeSample,
      insideMedium, penetrateSurface, isPrimaryIndirectSample);
  }
  else
  {
    for (int i = 0; i < M; ++i)
    {
      SurfaceMaterialInteractionSample bsdfSample;
      SurfaceMaterialInteractionLobeSample lobeSample;
      bool insideMedium0;
      polymorphicSurfaceMaterialInteractionCalcSample(
        polymorphicSurfaceMaterialInteraction, randomState, minimalRayInteraction,
        bsdfSample, lobeSample,
        insideMedium, penetrateSurface, isPrimaryIndirectSample);

      int2 address = pointDirectionToAddress(minimalSurfaceInteraction.position, bsdfSample.inputDirection);
      vec3 L = vec3(1);
      if (all(address != -1))
      {
        L = RadianceCache[address].xyz;
      }
      float srcPDF = bsdfSample.solidAnglePdf * lobeSample.pdf;
      float targetPDF = calcBt709Luminance(L * bsdfSample.throughput) * bsdfSample.solidAnglePdf;
      //float w = targetPDF / srcPDF;
      float w = calcBt709Luminance(L * bsdfSample.throughput) / lobeSample.pdf;
      weightSum += w;
      if (getNextSampleBlueNoise(randomState) * weightSum <= w )
      {
        surfaceMaterialInteractionSample = bsdfSample;
        surfaceMaterialInteractionLobeSample = lobeSample;
        finalTargetPDF = targetPDF;
        insideMedium = insideMedium0;
        finalL = L;
      }
    }
  }

  sampledLobe = surfaceMaterialInteractionLobeSample.lobe;
  sampledLobePdf = surfaceMaterialInteractionLobeSample.pdf;
  solidAnglePdf = min(surfaceMaterialInteractionSample.solidAnglePdf, float16Max);

  // Create a ray from the material sample

  Ray sampledRay = rayCreateDirection(
    minimalRayInteraction, minimalSurfaceInteraction, ray, surfaceMaterialInteractionSample.inputDirection, penetrateSurface);

  sampledRay.spreadAngle = calculateSpreadAngleFromSolidAnglePdf(sampledRay.spreadAngle, solidAnglePdf);

  // Combine sample throughput into the throughput
  if (useBSDFSampling)
  {
    const vec3 directionSampleThroughput = surfaceMaterialInteractionSample.throughput / surfaceMaterialInteractionLobeSample.pdf;
    throughput *= directionSampleThroughput;
  }
  else
  {
    //vec3 W = surfaceMaterialInteractionSample.throughput / finalTargetPDF * weightSum / M;
    vec3 normalizeTpt = normalize(surfaceMaterialInteractionSample.throughput);
    float3 W = normalizeTpt / calcBt709Luminance(finalL * normalizeTpt) * weightSum / M;
    throughput *= W;
  }

  return sampledRay;
}

Ray sampleDirection(
  inout RNG randomState, inout bool insideMedium, inout vec3 throughput,
  Ray ray, MinimalRayInteraction minimalRayInteraction, MinimalSurfaceInteraction minimalSurfaceInteraction,
  PolymorphicSurfaceMaterialInteraction polymorphicSurfaceMaterialInteraction,
  out uint8_t sampledLobe, bool isPrimaryIndirectSample)
{
  float16_t dummySampledLobePdf, dummySolidAnglePdf;

  return sampleDirection(
    randomState, insideMedium, throughput,
    ray, minimalRayInteraction, minimalSurfaceInteraction,
    polymorphicSurfaceMaterialInteraction, sampledLobe, dummySampledLobePdf, dummySolidAnglePdf, isPrimaryIndirectSample);
}

bool evalMediumChange(
  bool oldInsideMedium, bool insideMedium,
  PolymorphicSurfaceMaterialInteraction polymorphicSurfaceMaterialInteraction,
  inout uint16_t mediumMaterialIndex)
{
  // Set the material medium index if a medium was entered or exited
  // Note: This does not work for nested translucency as most recent medium entered is stored, but this is a fine thing to not support as
  // it is not super common. Additionally this path should only be invoked if PSTR is desired, and only in the case of actual thick translucency
  // which changes the medium flag.

  const bool enteredMedium = !oldInsideMedium && insideMedium;
  const bool exitedMedium = oldInsideMedium && !insideMedium;

  if (enteredMedium)
  {
    // Note: For now we always know the only type of material which can trigger this path is the translucent material, so no need to check it.
    const TranslucentSurfaceMaterialInteraction translucentSurfaceMaterialInteraction =
      translucentSurfaceMaterialInteractionCreate(polymorphicSurfaceMaterialInteraction);

    mediumMaterialIndex = translucentSurfaceMaterialInteraction.sourceSurfaceMaterialIndex;

    return true;
  }
  else if (exitedMedium)
  {
    mediumMaterialIndex = BINDING_INDEX_INVALID;

    return true;
  }

  return false;
}