/*
* Copyright (c) 2022-2023, NVIDIA CORPORATION. All rights reserved.
*
* Permission is hereby granted, free of charge, to any person obtaining a
* copy of this software and associated documentation files (the "Software"),
* to deal in the Software without restriction, including without limitation
* the rights to use, copy, modify, merge, publish, distribute, sublicense,
* and/or sell copies of the Software, and to permit persons to whom the
* Software is furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
* DEALINGS IN THE SOFTWARE.
*/
#pragma once

#include "rtx/concept/light/light_helper.slangh"

vec2 uvToBary(vec2 uv)
{
  return uv.x + uv.y < 1 ? uv : 1 - uv.yx;
}

float getLightSamplingSolidAnglePDF(float triangleArea, vec3 samplePosition, f16vec3 sampleNormal, vec3 surfacePosition)
{
  float areaPdf = 1.0 / triangleArea;
  vec3 offset = samplePosition - surfacePosition;
  float r2 = dot(offset, offset);
  float cosPhi = abs(dot(normalize(offset), sampleNormal));
  return cosPhi > 0 ? areaPdf * r2 / cosPhi : 0;
}


LightSample getLightSampleFromTriangle(int surfaceIndex, int primitiveIndex, vec2 uv, float trianglePdf, vec3 shadingPosition)
{
#define USE_SIMIPLIFIED_MODEL 1

  SURFACE_CREATE_READ(surface0, surfaceIndex, surfaces);
  Surface surface = surface0;
#if USE_SIMIPLIFIED_MODEL
  surface.isEmissive = false;
  surface.isEmissiveBlend = false;
  surface.isStatic = true;
  surface.isMatte = true;
  surface.texcoordGenerationMode = uint(TexGenMode::None);
  surface.previousPositionBufferIndex = BINDING_INDEX_INVALID;
  surface.normalBufferIndex = BINDING_INDEX_INVALID;
  surface.color0BufferIndex = BINDING_INDEX_INVALID;
  surface.isAnimatedWater = false;
  surface.textureAlphaArg1Source = uint(RtTextureArgSource::None);
  surface.textureAlphaArg2Source = uint(RtTextureArgSource::None);
  surface.textureAlphaOperation = uint(DxvkRtTextureOperation::Disable);
  surface.tFactor = 0;
#endif

  RayInteraction rayInteracton = {};
  rayInteracton.barycentricCoordinates = barycentricsToUint(uvToBary(uv));
  rayInteracton.primitiveIndex = primitiveIndex;
  rayInteracton.coneRadius = cb.neeCacheTextureSampleFootprintSize;
  Ray ray = {};
  ray.origin = shadingPosition;
  SurfaceInteraction surfaceInteraction = surfaceInteractionCreate(surface, rayInteracton, ray, false, kFootprintFromRayOrigin);
#if USE_SIMIPLIFIED_MODEL
  surfaceInteraction.positionError = 0;
  surfaceInteraction.motion = 0;
  surfaceInteraction.interpolatedTangent = f16vec3(0);
  surfaceInteraction.interpolatedBitangent = f16vec3(0);
  surfaceInteraction.vertexColor = f16vec4(0);
#endif

  rayInteracton.viewDirection = normalize(surfaceInteraction.position - shadingPosition);

  const MemoryPolymorphicSurfaceMaterial memoryPolymorphicSurfaceMaterial = surfaceMaterials[surface.surfaceMaterialIndex];
  const uint8_t polymorphicType = memoryPolymorphicSurfaceMaterialGetTypeHelper(memoryPolymorphicSurfaceMaterial);

  LightSample lightSample = {};
  lightSample.position = surfaceInteraction.position;
  lightSample.normal = surfaceInteraction.interpolatedNormal;
  float16_t lightPdf = trianglePdf * getLightSamplingSolidAnglePDF(
    surfaceInteraction.triangleArea, surfaceInteraction.position, surfaceInteraction.triangleNormal, shadingPosition);
  lightSample.solidAnglePdf = lightPdf;
  lightSample.radiance = 0;

  if (polymorphicType == surfaceMaterialTypeOpaque)
  {
    OpaqueSurfaceMaterial opaqueSurfaceMaterial = opaqueSurfaceMaterialCreate(surface.surfaceMaterialIndex, memoryPolymorphicSurfaceMaterial);
#if USE_SIMIPLIFIED_MODEL
    opaqueSurfaceMaterial.albedoOpacityTextureIndex = BINDING_INDEX_INVALID;
    opaqueSurfaceMaterial.normalTextureIndex = BINDING_INDEX_INVALID;
    opaqueSurfaceMaterial.tangentTextureIndex = BINDING_INDEX_INVALID;
    opaqueSurfaceMaterial.roughnessTextureIndex = BINDING_INDEX_INVALID;
    opaqueSurfaceMaterial.metallicTextureIndex = BINDING_INDEX_INVALID;
    opaqueSurfaceMaterial.anisotropy = 1.0;
    opaqueSurfaceMaterial.albedoOpacityConstant = 0.0;
    opaqueSurfaceMaterial.roughnessConstant = 0.0;
    opaqueSurfaceMaterial.metallicConstant = 0.0;
    opaqueSurfaceMaterial.spriteSheetRows = 0;
    opaqueSurfaceMaterial.spriteSheetCols = 0;
    opaqueSurfaceMaterial.spriteSheetFPS = 0;
    opaqueSurfaceMaterial.thinFilmThicknessConstant = 0.0;
    opaqueSurfaceMaterial.flags = 0;
#endif

    const OpaqueSurfaceMaterialInteraction opaqueSurfaceMaterialInteraction =
      opaqueSurfaceMaterialInteractionCreate(opaqueSurfaceMaterial, surface, surfaceInteraction, rayInteracton);

    lightSample.radiance = opaqueSurfaceMaterialInteraction.emissiveRadiance;
  }
  return lightSample;
}

void getTriangleLightFlux(int surfaceIndex, int primitiveIndex, out vec3 triangleCenter, out f16vec3 triangleNormal, out vec3 lightFlux)
{
  SURFACE_CREATE_READ(surface0, surfaceIndex, surfaces);    
  Surface surface = surface0;
  RayInteraction rayInteracton = {};
  rayInteracton.frontHit = true;
  rayInteracton.barycentricCoordinates = barycentricsToUint(uvToBary(vec2(1.0 / 3.0)));
  rayInteracton.primitiveIndex = primitiveIndex;

  Ray dummyRay;
  dummyRay.direction = f16vec3(1.0);
  SurfaceInteraction surfaceInteraction = surfaceInteractionCreate(surface, rayInteracton, dummyRay, false, kFootprintFromTextureCoordDiff);
  triangleCenter = surfaceInteraction.position;
  triangleNormal = surfaceInteraction.triangleNormal;
  lightFlux = vec3(0);

  const MemoryPolymorphicSurfaceMaterial memoryPolymorphicSurfaceMaterial = surfaceMaterials[surface.surfaceMaterialIndex];
  const uint8_t polymorphicType = memoryPolymorphicSurfaceMaterialGetTypeHelper(memoryPolymorphicSurfaceMaterial);

  if (polymorphicType == surfaceMaterialTypeOpaque)
  {
    OpaqueSurfaceMaterial opaqueSurfaceMaterial = opaqueSurfaceMaterialCreate(surface.surfaceMaterialIndex, memoryPolymorphicSurfaceMaterial);
    const OpaqueSurfaceMaterialInteraction opaqueSurfaceMaterialInteraction =
      opaqueSurfaceMaterialInteractionCreate(opaqueSurfaceMaterial, surface, surfaceInteraction, rayInteracton);

    lightFlux = opaqueSurfaceMaterialInteraction.emissiveRadiance * surfaceInteraction.triangleArea;
  }
}